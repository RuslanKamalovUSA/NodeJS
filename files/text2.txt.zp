MAXCODE.DEV
JAVASCRIPT
МЕТОДЫ JS
КАК ПОЛЬЗОВАТЬСЯ
ВИДЕО
НОВОСТИ
RUSLANKAMALOVUSA
САМОЕ ВАЖНОЕ ПРО ПРОМИСЫ
ПРИ РЕШЕНИИ ЗАДАЧ ПРО ПРОМИСЫ СОВЕТУЮ ПОДГЛЯДЫВАТЬ В ЭТУ ШПАРГАЛКУ. ТУТ В ФОРМАТЕ РАЗОБЛАЧЕНИЯ МИФОВ И ОТВЕТОВ НА ВОПРОСЫ Я ОПИСАЛ ОСНОВНЫЕ СИТУАЦИИ, КОТОРЫЕ ПРОИСХОДЯТ С ПРОМИСАМИ.

0. ЧТО ТАКОЕ ПРОМИС?
НА СОБЕСЕДОВАНИИ МОЖНО СКАЗАТЬ, ЧТО ПРОМИС — ЭТО ЭКЗЕМЛЯР КЛАССА PROMISE. А ДАЛЬШЕ ОПИСАТЬ, КАК ЭТОТ КЛАСС УСТРОЕН. ДЛЯ ТОГО, ЧТОБЫ ОПИСАТЬ КАКОЙ-ТО КЛАСС, ДОСТАТОЧНО ОПИСАТЬ ЕГО ВНУТРЕННЕЕ И ВНЕШНЕЕ УСТРОЙСТВО.

ВНУТРИ ПРОМИСА ХРАНЯТСЯ: СТАТУС ПРОМИСА, ЗНАЧЕНИЕ И ДВА НАБОРА ФУНКЦИЙ-ПОДПИСЧИКОВ (ПЕРВЫЙ НАБОР НА СЛУЧАЙ УСПЕШНОГО ЗАВЕРШЕНИЯ И ВТОРОЙ НА СЛУЧАЙ НЕУДАЧИ).

СТАТУС МОЖЕТ БЫТЬ PENDING, FULFILLED И REJECTED.
ИЗНАЧАЛЬНО ПРОМИС МОЖЕТ НАХОДИТЬСЯ В ЛЮБОМ ИЗ ТРЕХ СТАТУСОВ.
ПРОМИС МОЖЕТ ИЗМЕНИТЬ СТАТУС НЕ БОЛЕЕ ОДНОГО РАЗА (ТО ЕСТЬ ОДИН РАЗ ИЛИ НИ РАЗУ).
МОЖНО ПЕРЕЙТИ ИЗ СТАТУСА PENDING В FULFILLED ИЛИ ИЗ СТАТУСА PENDING В REJECTED, ДРУГИХ ВАРИАНТОВ НЕТ.
В СОСТОЯНИИ PENDING ПРОМИС НЕ ХРАНИТ НИКАКОЕ ЗНАЧЕНИЕ. В СОСТОЯНИИ FULFILLED ОН ХРАНИТ VALUE. В СОСТОЯНИИ REJECTED ХРАНИТ REASON.
НАПРЯМУЮ (НАПРИМЕР, ОБРАТИВШИСЬ К КАКОМУ-ТО ПОЛЮ ОБЪЕКТА ПРОМИСА) ПОЛУЧИТЬ VALUE ИЛИ REASON НЕЛЬЗЯ.
СНАРУЖИ У ПРОМИСА ДОСТУПНЫ: КОНСТРУКТОР И ТРИ МЕТОДА THEN/CATCH/FINALLY, А ТАКЖЕ НЕСКОЛЬКО СТАТИЧЕСКИХ МЕТОДОВ (НАПРИМЕР, PROMISE.ALL).

ОСНОВНОЙ МЕТОД — THEN. С ПОМОЩЬЮ НЕГО МЫ МОЖЕМ «ПОДПИСАТЬСЯ» НА СОБЫТИЕ ИЗМЕНЕНИЯ СТАТУСА ПРОМИСА.
МЕТОД THEN ПРИНИМАЕТ ДВА АРГУМЕНТА-КОЛБЭКА. ПЕРВЫЙ ПОПАДАЕТ В НАБОР ФУНКЦИЙ ДЛЯ ВЫПОЛНЕНИЯ В СЛУЧАЕ УСПЕХА, А ВТОРОЙ — В НАБОР НА СЛУЧАЙ НЕУДАЧИ.
В ТОТ МОМЕНТ, КОГДА ПОМЕНЯЕТСЯ СТАТУС ПРОМИСА, ВЫЗОВУТСЯ ЛИБО ВСЕ ПОДПИСЧИКИ ИЗ ПЕРВОГО НАБОРА, ЛИБО ВСЕ ПОДПИСЧИКИ ИЗ ВТОРОГО НАБОРА. ПОДРОБНЕЕ СМ. П. 2.
МЕТОДЫ CATCH И FINALLY ФАКТИЧЕСКИ ЯВЛЯЮТСЯ ОБЕРТКАМИ НА THEN И СЛУЖАТ ТОЛЬКО ДЛЯ НАПИСАНИЯ БОЛЕЕ ЛАКОНИЧНОГО КОДА
1. МЕТОДЫ ПРОМИСОВ ВЫПОЛНЯЮТСЯ СИНХРОННО!
РАССМОТРИМ КОД:


PROMISE.RESOLVE(1)
  .THEN(X => X + 1)
  .CATCH(X => X + 2)
  .THEN(X => X + 3)
В ЭТОМ КОДЕ СОЗДАЕТСЯ 4 ПРОМИСА! ВСЕ ОНИ СОЗДАЮТСЯ СИНХРОННО!

ПОСЛЕ ВЫПОЛНЕНИЯ ЭТОГО КОДА ЕСТЬ ОДИН ПРОМИС В СОСТОЯНИИ FULFILLED (ПОТОМУ ЧТО PROMISE.RESOLVE, ЕСЛИ ТУДА ПЕРЕДАТЬ НЕ THENABLE ОБЪЕКТ, ВСЕГДА ВОЗВРАЩАЕТ FULFILLED ПРОМИС).

И ЕСТЬ ЕЩЕ ТРИ ПРОМИСА, НАХОДЯЩИХСЯ В СОСТОЯНИИ PENDING. МЕТОДЫ THEN/CATCH/FINALLY ВСЕГДА ВОЗВРАЩАЮТ ПРОМИС В СОТОЯНИИ PENDING. ДАЖЕ ЕСЛИ ПРОМИС, НА КОТОРОМ ОНИ ВЫЗЫВАЮТСЯ, НАХОДИТСЯ В ЗАВЕРШЕННОМ СОСТОЯНИИ.

2. В КАКОЙ МОМЕНТ ВЫПОЛНЯЕТСЯ КОЛБЭК THEN?
КОД ВНУТРИ THEN НИКОГДА НЕ ВЫПОЛНЯЕТСЯ СИНХРОННО!

РАССМОТРИМ КОД:


P.THEN(CB)
ЕСЛИ P НАХОДИТСЯ В СОСТОЯНИИ PENDING, ТО В МОМЕНТ ИЗМЕНЕНИЯ СТАТУСА ПРОМИСА P С PENDING НА FULFILLED ФУНКЦИЯ CB ОТПРАВИТСЯ В ОЧЕРЕДЬ МИКРОТАСКОВ. КОГДА ОСОВОБОДИТСЯ КОЛСТЕК И КОГДА ДОЙДЕТ ОЧЕРЕДЬ ДО ЭТОЙ ТАСКИ, МЫ ДОСТАНЕМ ЕЕ, ПОЛОЖИМ НА КОЛСТЕК И ВЫПОЛНИМ.

МЕНЕЕ ИЗВЕСТНЫЙ ФАКТ: ДАЖЕ ЕСЛИ P НАХОДИТСЯ В СОСТОЯНИИ FULLFILLED, ФУНКЦИЯ CB ВСЕ РАВНО НЕ ВЫПОЛНИТСЯ СРАЗУ. ОНА ОТПРАВИТСЯ В ОЧЕРЕДЬ МИКРОТАСКОВ. НО ОНА НЕ ВЫПОЛНИТСЯ СИНХРОННО. СНАЧАЛА ОНА ПОПАДАЕТ В ОЧЕРЕДЬ, ДАЛЕЕ МЫ ДОСТАЕМ ИЗ ОЧЕРЕДИ ВСЕ, ЧТО ТАМ ЛЕЖАЛО ДО НЕЕ, И ТОЛЬКО ПОТОМ ДОСТАЕМ ЕЕ.

3. ОПРЕДЕЛЯЕМ, В КАКОЙ КОЛБЭК МЫ ПОПАЛИ
РАССМОТРИМ КОД, ГДЕ НА PROMISE1 МЫ ПОДПИСЫВАЕМСЯ ЧЕРЕЗ МЕТОД THEN, А НА PROMISE2 ЧЕРЕЗ МЕТОД CATCH.


CONST RESULT1 = PROMISE1.THEN(CB1, CB2);
CONST RESULT2 = PROMISE2.CATCH(CB2);
ОТ СОСТОЯНИЯ PROMISE1/PROMISE2 ЗАВИСИТ ТОЛЬКО ТО, В КАКОЙ КОЛЛБЭК МЫ ПАПАДЕМ. СОСТОЯНИЕ ПРОМИСА RESULT1/RESULT2 (КОТОРЫЙ ВОЗВРАЩАЕТСЯ THEN ИЛИ CATCH) НЕ ЗАВИСИТ ОТ СОСТОЯНИЯ PROMISE1/PROMISE2!

ЕСЛИ PROMISE1 FULFILLED, ТО МЫ ВЫПОЛНЯЕМ CB1 (ДАЛЕЕ СМ. П. 5)
ЕСЛИ PROMISE1 REJECTED, ТО МЫ ВЫПОЛНЯЕМ CB2 (ДАЛЕЕ СМ. П. 5)
ЕСЛИ PROMISE2 REJECTED, ТО МЫ ВЫПОЛНЯЕМ CB2 (ДАЛЕЕ СМ. П. 5)
ЕСЛИ PROMISE2 REJECTED, ТО СB1 И CB2 НЕ ВЫПОЛНЯЮТСЯ
ДАЛЕЕ В П. 5 МЫ УВИДИМ, КАК ОПРЕДЕЛЯЕТСЯ СТАТУС ПРОМИСА В ЗАВИСИМОСТИ ОТ КОЛБЭКОВ CB1 И CB2. НО ЧТО ПРОИСХОДИТ В ПОСЛЕДНЕМ СЛУЧАЕ, КОГДА КОЛБЭКИ ВООБЩЕ НЕ ВЫЗЫВАЮТСЯ?

4. ЧТО БУДЕТ, ЕСЛИ ПЕРЕДАТЬ В THEN НЕ ФУНКЦИЮ?
РАССМОТРИМ КОД


PROMISE1.THEN(VAL1, VAL2)
PROMISE2.CATCH(VAL2)
ПУСТЬ В МЕТОД THEN ПРОМИСА PROMISE1 МЫ ПЕРЕДАЛИ НЕ ФУНКЦИЮ (А МАССИВ, СТРОКУ, ЧИСЛО, ДРУГОЙ ПРОМИС ИЛИ ЧТО-ТО ЕЩЕ). КСТАТИ, ЕСЛИ МЫ ВЫЗВАЛИ THEN С ОДНИМ АРГУМЕНТОМ, ТО ЭТО ТО ЖЕ САМОЕ, ЧТО ПЕРЕДАТЬ ВМЕСТО VAL2 UNDEFINED.

В ЭТОМ СЛУЧАЕ В ЗАВИСИМОСТИ ОТ АРГУМЕНТА ЭТО ЗНАЧЕНИЕ, КОТОРОЕ НЕ ФУНКЦИЯ, ЗАМЕНЯЕТСЯ НА ФУНКЦИЮ.

VAL1 ЗАМЕНЯЕТСЯ НА X => X
VAL2 ЗАМЕНЯЕТСЯ НА X => { THROW X }
НАПРИМЕР, КОД


PROMISE.REJECT(5).THEN(X => X + 1)
ЭКВИВАЛЕНТЕН КОДУ


PROMISE.REJECT(5).THEN(X => X + 1, X => { THROW X })
ТО ЖЕ САМОЕ ПРОИСХОДИТ С CATCH. ТАК КАК МЫ УКАЗЫВАЕМ ТОЛЬКО ВТОРОЙ КОЛБЭК (ФОРМАЛЬНО ОН ПЕРВЫЙ И ЕДИНСТВЕННЫЙ, НО ФАКТИЧЕСКИ ЭТО АНАЛОГ ВТОРОГО КОЛБЭКА THEN), ТО ПЕРВЫЙ МЫ НЕ УКАЗЫВАЕМ ВООБЩЕ. МОЖНО СКАЗАТЬ, ЧТО VAL1 ДЛЯ CATCH ЭТО UNDEFINED. А ЭТО ЗНАЧИТ, ЧТО ЭТОТ КОЛБЭК ЗАМЕНЯЕТСЯ НА X => X.

РАССМОТРИМ КОД


CONST RESULT = PROMISE.CATCH(CB)
В СЛУЧАЕ, КОГДА ПРОМИС PROMISE НАХОДИТСЯ В СТАТУСЕ FULFILLED СО ЗНАЧАЕНИЕМ VALUE, ОН ВОЗВРАЩАЕТ НОВЫЙ ПРОМИС RESULT, КОТОРЫЙ ТОЖЕ НАХОДИТСЯ В СТАТУСЕ FULFILLED СО ЗНАЧЕНИЕМ VALUE.

5. КАК ОПРЕДЕЛИТЬ СТАТУС ВОЗВРАЩАЕМОГО ПРОМИСА?
ПОСМОТРИМ ЕЩЕ РАЗ НА КОД:


CONST RESULT1 = PROMISE1.THEN(CB1, CB2);
CONST RESULT2 = PROMISE2.CATCH(CB2);
ПОСЛЕ ТОГО КАК МЫ ПОПАЛИ В CB1 ИЛИ CB2 НАМ УЖ НЕ ВАЖНО КАК МЫ ТУДА ПОПАЛИ! СОСТОЯНИЕ PROMISE1/PROMISE2 ВООБЩЕ НИКАК НЕ ВЛИЯЕТ НА СОСТОЯНИЕ RESULT1/RESULT2. ЕДИНСТВЕННОЕ, ЧТО ВЛИЯЕТ — ЧТО ПРОИСХОДИТ В КОЛБЭКЕ CB1/CB2.

ЕЩЕ РАЗ НАПОМНЮ, ЕСЛИ CB1/CB2 НЕ ПЕРЕДАН ИЛИ ЯВЛЯЕТСЯ НЕ ФУНКЦИЕЙ, ТО ПРОИСХОДИТ АВТОМАТИЧЕСКАЯ ЗАМЕНА НА СООТВЕТСТВУЮЩУЮ ФУНКЦИЮ (СМ. П. 4).

ПОСЛЕ ЭТОГО СОСТОЯНИЕ RESULT1/RESULT2 ОПРЕДЕЛЯЕТСЯ ИСКЛЮЧИТЕЛЬНО ПОВЕДЕНИЕМ ВНУТРИ КОЛБЭКА, КОТОРЫЙ МЫ ВЫЗВАЛИ (КАК МЫ ВЫБРАЛИ ЭТОТ КОЛБЭК — СМ П. 3).

С ТОЧКИ ЗРЕНИЯ АЛГОРИТМА НИЖЕ ВСЕ ЭТИ СИТУАЦИИ РАССМАТРИВАЮТСЯ ОДИНАКОВО


CONST RESULT = PROMISE.THEN(CB);
CONST RESULT = PROMISE.THEN(×××, CB);
CONST RESULT = PROMISE.CATCH(CB);
ИЗНАЧАЛЬНО RESULT ВСЕГДА НАХОДИТСЯ В СОСТОЯНИИ PENDING, НО ДАЛЬШЕ:

ЕСЛИ В КОЛБЭКЕ CB ВОЗВРАЩАЕТСЯ ОБЫЧНОЕ ЗНАЧЕНИЕ VALUE (НЕ ПРОМИС) ИЛИ НЕ ВОЗВРАЩАЕТСЯ НИЧЕГО (ТО ЕСТЬ ФАКТИЧЕСКИ VALUE РАВНО UNDEFINED), ТО ПРОМИС RESULT СТАНОВИТСЯ FULFILLED СО ЗНАЧЕНИЕМ VALUE.
ЕСЛИ В КОЛБЭКЕ CB БРОСАЕТСЯ ЗНАЧЕНИЕ REASON (THROW REASON), ТО ПРОМИС RESULT СТАНОВИТСЯ REJECTED СО ЗНАЧЕНИЕМ REASON.
ЕСЛИ В КОЛБЭКЕ CB ВОЗВРАЩАЕТСЯ ПРОМИС, ТО ПРОМИС RESULT ПОЛУЧАЕТ ТО ЖЕ САМОЕ ЗНАЧЕНИЕ И ТОТ ЖЕ САМЫЙ СТАТУС, ЧТО ЭТОГО ВОЗВРАЩАЕМОГО ПРОМИСА ВНУТРИ CB.
6. ЗАЧЕМ НУЖЕН МЕТОД CATCH?

P1.THEN(CB1).CATCH(CB2); // #1
P1.THEN(CB1, CB2);       // #2
ЭТИ ДВЕ СТРОЧКИ ПОХОЖИ, НО РАБОТАЮТ ПО-РАЗНОМУ! ЕСЛИ ВЫ ХОТИТЕ ОБРАБОТАТЬ ОБЕ СИТУАЦИИ — УСПЕШНОЕ И НЕУСПЕШНОЕ ЗАВЕРШЕНИЕ — ИСПОЛЬЗУЙТЕ ВСЕГДА ВТОРОЙ ВАРИАНТ.

МЕТОД CATCH СЛЕДУЕТ ИСПОЛЬЗОВАТЬ ТОЛЬКО В ДВУХ СЛУЧАЯХ:

КОГДА ВООБЩЕ НЕ ТРЕБУЕТСЯ ОБРАБОТКА ПОЗИТИВНОГО СЦЕНАРИЯ И НУЖНО ВЫПОЛНИТЬ КОЛБЭК ТОЛЬКО В СЛУЧАЕ РЕДЖЕКТА.
КОГДА НУЖНО ОДНИМ КОЛБЭКОМ ОБРАБОТАТЬ ОШИБКУ ИЗ НЕСКОЛЬКИХ МЕСТ. В ПРИМЕРЕ #1 CB2 ОБРАБАТЫВАЕТ СЛУЧАЙ РЕЖДЖЕКТА P1 И ОШИБКУ В CB1. В ПРИМЕРЕ #2 CB2 ОБРАБАТЫВАЕТ ТОЛЬКО СЛУЧАЙ РЕЖДЖЕКТА P1.
7. КОНСТРУКТОР PROMISE РАБОТАЕТ СИНХРОННО
В П. 2 Я НАЧАЛ С ТОГО, ЧТО THEN/CATCH/FINALLY ВСЕГДА ВОЗВРАЩАЮТ ПРОМИС В СОСТОЯНИИ PENDING. КОНСТРУКТОР PROMISE МОЖЕТ ВОЗВРАЩАТЬ ПРОМИС, КОТОРЫЙ СРАЗУ НАХОДИТСЯ В ТЕРМИНАЛЬНОМ СОСТОЯНИИ (FULFILLED ИЛИ REJECTED).


CONSOLE.LOG(1);
CONST PROMISE = NEW PROMISE(RESOLVE => {
  CONSOLE.LOG(2);
  RESOLVE("HELLO");
  CONSOLE.LOG(3);
});
CONSOLE.LOG(4);
CONSOLE.LOG(PROMISE);
ЦИФРЫ 1, 2, 3, 4 ВЫВЕДУТСЯ ПО ПОРЯДКУ. ПРОМИС PROMISE В МОМЕНТ ВЫЗОВА RESOLVE МЕНЯЕТ СТАТУС. ТО ЕЩЕ ДО ВЫВОДА ЧИСЛА 3 ОН СТАНЕТ FULFILLED. ЕСЛИ МЫ ЕГО ВЫЕДЕМ СРАЗУ ПОСЛЕ ПРОМИСА В КОНСОЛЬ, ТО УВИДИМ ЕГО ЗНАЧЕНИЕ. ЕСЛИ БЫ ОН СТАНОВИЛСЯ FULFILLED КАК-ТО АСИНХРОННО, ТО ЕСТЬ ПРОХОДЯ ЧЕРЕЗ ОЧЕРЕДЬ ТАСОК, ТО В СИНХРОННОМ КОДЕ МЫ БЫ УВИДЕЛИ PENDING.

ИЗБРАННОЕ ИЗ MDN
ТАКЖЕ РЕКОМЕНДУЮ ПРОЧИТАТЬ 4 СТАТЬИ НА MDN: ПРО ПРОМИСЫ В ЦЕЛОМ, ПРО МЕТОДЫ THEN И CATCH И ПРО КОНСТРУКТОР. НИЖЕ Я СОБРАЛ САМУЮ ВАЖНУЮ ИНФОРМАЦИЮ ИЗ ЭТИХ РАЗДЕЛОВ.

PROMISE

THEN

CATCH

CONSTRUCTOR

СИНЯКОВ МАКСИМ АЛЕКСЕЕВИЧ | ИНН 780108986188
ПОЧТА: MAX@SINYAKOV.COM, ТЕЛЕГРАМ: @MAXSINYAKOV